https://github.com/mountainstorm/Flow/
http://stackoverflow.com/questions/27234987/how-to-detect-application-terminate-in-kernel-extension-mac-os-x
https://github.com/gdbinit/santa
https://www.exploit-db.com/papers/13176/
http://shakthimaan.com/downloads/hurd/server_writer.pdf
https://spin.atomicobject.com/2015/11/17/vagrant-osx/
https://developer.apple.com/library/mac/technotes/tn2127/_index.html#//apple_ref/doc/uid/DTS10003591-CH1-SECTION2
https://www.synack.com/2015/11/17/monitoring-process-creation-via-the-kernel-part-i/
https://github.com/facebook/osquery
https://capnproto.org/language.html
https://blake2.net/
https://www.schneier.com/cryptography/skein/
https://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt
https://github.com/bazelbuild/bazel/blob/master/tools/cpp/CROSSTOOL
https://www.chromium.org/developers/testing/isolated-testing/deterministic-builds
https://codereview.chromium.org/699083004
CppCompileAction.java options.add("-frandom-seed=" + outputFile.getExecPathString());
https://lwn.net/Articles/630074/
https://wiki.debian.org/ReproducibleBuilds/Howto
https://github.com/sevki/build

https://github.com/apenwarr/redo#readme
http://cr.yp.to/redo/honest-script.html

Differences from Ninja:
* Dependencies of builds steps that have been run are deduced from the files that the build
  step read instead of relying on the information in the manifest. (mscv_deps_prefix, deps
  and depfile are ignored, other than that the .d file is removed)
* File hashes are used rather than mtimes (except for generator rules, they still use mtimes)
* msvc_deps_prefix, deps, depfile are unnecessary (except that the .d file should be removed)
* Supports multiple outputs even when deps is specified.
* When the console pool is used, the command is always rebuilt. Reason being
  stdin is not a deterministic source, and it tends to be used for things as tests
  and generator rules anyway.
* Does not fail the build on missing inputs.
* Commands run have only very limited exposure to environment variables

Errors that Shuriken does not detect:
* Nondeterministic problems in invoked build steps
* Build steps whose output depend on certain files *missing*
* Build steps that read from or append to an output file
* Build steps that depend on the contents of system wide folders such as
  /etc, /tmp, /Applications.

Build steps in Shuriken must fulfill the following requirements:
* Must be a pure function; given the same input must generate the same output
* The output must be written only as files and output to stdin/stderr
* The input must be read only from the file system, from the command line and from
  environment variables. This means that input must not come from stdin, network, other
  processes, devices etc. Ideally it should also not depend on time or randomness.
* Must not modify input files. This also includes that input files must not be moved.
  (Every file that the build step did not create is an input file.)
* When inputs are outputs of other build steps, those must be declared as dependencies.
* When the command of the build step returns, all of the processes it created must be dead.

Things to do for increased build correctness:
* Distinguish between read contents vs read metadata in the invocation log;
  if only metadata is read, make sure to write a metadata entry there. Or is this
  good?
* Check that there are no files that are generated by more than one invocation (lint the manifest)
* Keep a map from (st_dev, st_ino) => Path. Whenever a directory is created because
  it was missing when the build started, and it turns out that it has already been
  created by someone else, make sure that its (st_dev, st_ino) is not the same as
  some other path that we have seen. That means hardlink and could break the build.
* Need to detect and fail on directories that would have been created to do the
  build that are hard links to each other.
* Validate that the command did not read a file that is an output
  of a target that it does not depend on directly or indirectly.
* No two Paths that case fold/normalize to the same path but have different non
  case folded/normalized representations.
* Function to detect insufficiently declared dependencies (how to do this?)
* Shield commands from env vars
* Make sure the build does the right thing even if targets are specified wrong on the command line
* Keep a map of files that have been read so far by the build. If any step
  writes to any of those file, there is a dependency error in the build.
  (Is this generic enough? Can it be made to always find this error instead of
  just sometimes?)

Aesthetic bugs:
* Deal with depfile files: Don't treat them as outputs

Large things remaining to do:
* Share stat cache between manifest parsing / invocation log parsing and cleanliness check:
  * Move detail::StatMemo out to its own file with tests and stuff
  * Pass StatMemo as a parameter to Paths' constructor
  * Pass StatMemo to build, which passes it to computeCleanSteps, which passes it to isClean, which passes it to checkFingerprintMatches, which passes it to fingerprintMatches, which passes it to fingerprintStat.
  * Make fingerprintStat share stat cache with Paths for initial processing
* Optimize stat cache: We can share the entry if lstat said it was not a symlink.
* Fix: Status often says things like [5/4]
* Do something about generator rules. It's not nice that they are re-run directly after. Perhaps emulate ninja's behavior.
  * Pass Step object to CommandRunner. That way we get dependencies, generator status etc.
  * Don't trace generator rules with shk-trace. Instead just use inputs + implicit_inputs + outputs from the manifest.
  * depfile + generator rules are not supported. Otherwise it would be necessary to run the rule again just to get the deps.
  * Use mtime and not file hash to decide if generator rules are clean or not
  * Update docs for generator rules in step.h
* Mach port already in use. Is there already a server running?
  ^^^ This happens almost always when running CMake, because it will start shk-trace again directly after
* New (post shk-trace) tracer race(?):
  * shk: build failed: Dependency cycle: systemtest/systemtest -> /Users/peck/prog/client-core/build.shk/vendor/cmake/libvorbis/libvorbis.a -> /Users/peck/prog/client-core/build.shk/vendor/cmake/libvorbis/CMakeFiles/vorbis.dir/__/__/libvorbis/lib/floor1.c.o -> /Users/peck/prog/client-core/build.shk/vendor/cmake/libogg/libogg.a -> /Users/peck/prog/client-core/build.shk/vendor/cmake/libogg/CMakeFiles/ogg.dir/__/__/libogg/src/framing.c.o -> /Users/peck/prog/client-core/build.shk/vendor/cmake/libogg/libogg.a -> systemtest/systemtest
* Detect and reject undeclared dependencies
* Handle restat rules. OR: Make it the default somehow. Shuriken will not just stat but even hash all output files.
* Distributed caching
  * Cache key generation logic
  * Logic to make and receive cache lookup requests
  * Logic for uploading and receiving uploads of cache entries
  * Logic for bypassing command invocation when there is a cache hit
  * FUSE faulty file system

* Possible optimizations
  * Compile the manifest into a flatbuffer, for faster parsing later.
  * It seems like deallocating memory at the end of a no-op operation can take some time. Perhaps just exit directly?
  * Check if using mmap can speed things up in readFile/hashFile
  * Try reduce number of /bin/sh invocations per command. I think it's 3 now
  * See if adding HAVE_SSSE3, HAVE_XOP, HAVE_SSE41 etc flags for blake2 makes sense
  * Don't calculate hashes twice for racily clean files
  * Building core
    * With ninja from clean: 23m27.851s
    * With shk from clean: 23m57.228s
    * shk build after clean build, time to re-hash outputs: 0m50.672s

* Unit test BuildStatus
* Write documentation
* Fuzz test parsers (invocation log, sandbox, manifest)
* Check test coverage and add missing unit tests

To fill in the first test:
* Generate actual DAG in gen::buildInput
* Add assertions to the property



Can be done later:
* Fix cleaning:
  * Don't clean things written by generator rules
  * Test that directories created by the build system are cleaned
    @with_testdir('target_in_subdir')
    def test_full_clean_with_created_dirs(self):
      subprocess.check_output(shk, stderr=subprocess.STDOUT, shell=True)
      self.assertTrue(os.path.exists('dir/out'))
      self.assertTrue(os.path.exists('.shk_log'))
      output = subprocess.check_output(shk + ' -t clean', stderr=subprocess.STDOUT, shell=True)
      self.assertFalse(os.path.exists('dir/out'))
      self.assertFalse(os.path.exists('dir'))
      self.assertFalse(os.path.exists('.shk_log'))
      self.assertRegexpMatches(output, r'cleaned 3 files\.')
* CLI tools:
  * graph (graphviz)
  * query
  * targets
  * compdb
