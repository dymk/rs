namespace ShkCache;

/// Hash is a 20 byte struct containing a hash.
struct Hash {
  h00: byte;
  h01: byte;
  h02: byte;
  h03: byte;
  h04: byte;
  h05: byte;
  h06: byte;
  h07: byte;
  h08: byte;
  h09: byte;
  h10: byte;
  h11: byte;
  h12: byte;
  h13: byte;
  h14: byte;
  h15: byte;
  h16: byte;
  h17: byte;
  h18: byte;
  h19: byte;
}

/// A SecondaryIndexKey identifies an undeclared (not in the manifest) input
/// file that a build command used: It has its path and a hash that identifies
/// the file contents.
table SecondaryIndexKey {
  root_name: string;
  path: string;
  fingerprint: Hash;
}

enum Encoding : byte {
  Raw
}

enum Type : byte {
  File,
  Symlink
}

/// An IndexFileReference points to an output file of a build step.
table IndexFileReference {
  path: string;
  /// The file mode. Valid values are 0755 and 0644.
  mode: ubyte;
  encoding: Encoding;
  type: Type;
  store_key: Hash;
}

/// An IndexEntry represents the inputs and outputs of one invocation of a build
/// step. When saving an invocation to the cache, this is the thing that is
/// eventually written (after the actual output files have been uploaded).
table IndexEntry {
  primary_key: Hash;
  secondary_keys: [SecondaryIndexKey];
  files: [IndexFileReference];
}

/// Like a CompactSecondaryIndexKey but is a more compact representation, for
/// efficient lookups. It has a meaning only in the context of a Lookup request.
struct CompactSecondaryIndexKey {
  /// An index to the strings list of the ongoing IndexLookupRequest
  root_name: int;
  /// An index to the strings list of the ongoing IndexLookupRequest
  path: int;
  fingerprint: Hash;
}

table IndexLookupEntry {
  /// primary_key is an index in the primary_keys array sent in the
  /// IndexLookupRequest that this is a response to.
  primary_key: int;
  secondary_keys: [CompactSecondaryIndexKey];
  file_list: Hash;
}

table IndexInsertRequest {
  entries: [IndexEntry];
}

table IndexInsertResponse {
}

table IndexLookupRequest {
  primary_keys: [Hash];
  cancel_primary_keys: [int];
}

table IndexLookupResponse {
  /// lz4 compressed list of null-terminated path strings
  strings: [byte];
  entry: IndexEntry;
}

table GetFileListRequest {
  file_list: Hash;
}

table GetFileListResponse {
  files: [IndexFileReference];
}

rpc_service Index {
  Insert(IndexInsertRequest): IndexInsertResponse (idempotent);
  Lookup(IndexLookupRequest): IndexLookupResponse (streaming: "bidi", idempotent);
  GetFileList(GetFileListRequest): GetFileListResponse (idempotent);
}

table StoreInsertRequest {
  expiry: long;
  contents: [ubyte];
}

table StoreInsertResponse {
  key: Hash;
  expiry: long;
}

table StoreGetRequest {
  key: Hash;
}

table StoreGetResponse {
  expiry: long;
  contents: [ubyte];
}

table StoreTouchRequest {
  key: Hash;
  expiry: long;
}

table StoreTouchResponse {
}

rpc_service Store {
  /// Insert an entry into the Store.
  Insert(StoreInsertRequest): StoreInsertResponse (idempotent);

  /// Check if an entry is already present in the store. If so, bump its expiry,
  /// otherwise tell the client that it is absent. (This is used prior to making
  /// an Insert call, to avoid having to upload things if they are already
  /// there.)
  Touch(StoreTouchRequest): StoreTouchResponse (idempotent);

  /// Download an entry from the Store.
  Get(StoreGetRequest): StoreGetResponse (idempotent);
}

table StoreConfig {
  /// In bytes, counting the content size. When an entry is larger than this, it
  /// should be chunked by the client.
  soft_store_entry_size_limit: ulong;
  /// In bytes, counting the content size. The server will refuse to store
  /// entries that are larger than this.
  hard_store_entry_size_limit: ulong;
}

table ConfigGetRequest {
}

table ConfigGetResponse {
  config: StoreConfig;
}

rpc_service Config {
  Get(ConfigGetRequest): ConfigGetResponse (idempotent);
}
