/*
 *
 * Copyright 2015 gRPC authors, 2017 Per Gr√∂n.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include <map>

#include "generator.h"

namespace rs_grpc_generator {
namespace {

std::string FilenameIdentifier(const std::string &filename) {
  std::string result;
  for (unsigned i = 0; i < filename.size(); i++) {
    char c = filename[i];
    if (isalnum(c)) {
      result.push_back(c);
    } else {
      static char hex[] = "0123456789abcdef";
      result.push_back('_');
      result.push_back(hex[(c >> 4) & 0xf]);
      result.push_back(hex[c & 0xf]);
    }
  }
  return result;
}

std::map<std::string, std::string> GetSharedVars(
    const grpc_generator::File &file,
    const Parameters &params) {
  std::map<std::string, std::string> vars;
  if (!params.rs_services_namespace.empty()) {
    vars["ns"] = params.rs_services_namespace + "::";
    vars["prefix"] = params.rs_services_namespace;
  } else {
    vars["ns"] = "";
    vars["prefix"] = "";
  }
  if (!params.grpc_services_namespace.empty()) {
    vars["grpc_ns"] = params.grpc_services_namespace + "::";
    vars["grpc_prefix"] = params.grpc_services_namespace;
  } else {
    vars["grpc_ns"] = "";
    vars["grpc_prefix"] = "";
  }

  return vars;
}

}  // namespace

template <class T, size_t N>
T *array_end(T (&array)[N]) {
  return array + N;
}

void PrintIncludes(
    grpc_generator::Printer *printer,
    const std::vector<std::string> &headers,
    const Parameters &params) {
  std::map<std::string, std::string> vars;

  vars["l"] = params.use_system_headers ? '<' : '"';
  vars["r"] = params.use_system_headers ? '>' : '"';

  auto &s = params.grpc_search_path;
  if (!s.empty()) {
    vars["l"] += s;
    if (s[s.size() - 1] != '/') {
      vars["l"] += '/';
    }
  }

  for (auto i = headers.begin(); i != headers.end(); i++) {
    vars["h"] = *i;
    printer->Print(vars, "#include $l$$h$$r$\n");
  }
}

std::string GetHeaderPrologue(
    grpc_generator::File *file,
    const Parameters & /*params*/) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;

    vars["filename"] = file->filename();
    vars["filename_identifier"] = FilenameIdentifier(file->filename());
    vars["filename_base"] = file->filename_without_ext();
    vars["message_header_ext"] =
        grpc_cpp_generator::kCppGeneratorMessageHeaderExt;
    vars["service_header_ext"] = ".grpc.pb.h";

    printer->Print(
        vars, "// Generated by the rs-grpc plugin.\n");
    printer->Print(
        vars, "// If you make any local change, they will be lost.\n");
    printer->Print(vars, "// source: $filename$\n");
    std::string leading_comments = file->GetLeadingComments("//");
    if (!leading_comments.empty()) {
      printer->Print(vars, "// Original file comments:\n");
      printer->Print(leading_comments.c_str());
    }
    printer->Print(vars, "#ifndef RSGRPC_$filename_identifier$__INCLUDED\n");
    printer->Print(vars, "#define RSGRPC_$filename_identifier$__INCLUDED\n");
    printer->Print(vars, "\n");
    printer->Print(vars, "#include \"$filename_base$$message_header_ext$\"\n");
    printer->Print(vars, "#include \"$filename_base$$service_header_ext$\"\n");
    printer->Print(vars, file->additional_headers().c_str());
    printer->Print(vars, "\n");
  }
  return output;
}

std::string GetHeaderIncludes(
    grpc_generator::File *file,
    const Parameters &params) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;

    static const char *headers_strs[] = {
        "grpc++/impl/codegen/stub_options.h",
        "rs/publisher.h",
        "rs-grpc/server.h",
        "rs-grpc/service.h"};
    std::vector<std::string> headers(headers_strs, array_end(headers_strs));
    PrintIncludes(printer.get(), headers, params);
    printer->Print(vars, "\n");
    printer->Print(vars, "namespace grpc {\n");
    printer->Print(vars, "class ChannelInterface;\n");
    printer->Print(vars, "}  // namespace grpc\n\n");
    printer->Print(vars, "namespace shk {\n");
    printer->Print(vars, "class CallContext;\n");
    printer->Print(vars, "}  // namespace shk\n\n");

    if (!file->package().empty()) {
      std::vector<std::string> parts = file->package_parts();

      for (auto part = parts.begin(); part != parts.end(); part++) {
        vars["part"] = *part;
        printer->Print(vars, "namespace $part$ {\n");
      }
      printer->Print(vars, "\n");
    }
  }
  return output;
}

void PrintHeaderMethod(
    grpc_generator::Printer *printer,
    const grpc_generator::Method *method,
    std::map<std::string, std::string> *vars) {
  (*vars)["Method"] = method->name();
  (*vars)["RequestPrelude"] =
      method->ClientStreaming() ? "::shk::AnyPublisher<" : "";
  (*vars)["Request"] = method->input_type_name();
  (*vars)["RequestPostlude"] =
      method->ClientStreaming() ? ">" : "";
  (*vars)["Response"] = method->output_type_name();
  (*vars)["ResponseStream"] = method->ServerStreaming() ? "/*stream*/ " : "";
  (*vars)["RequestPlural"] = method->ClientStreaming() ? "s" : "";
  printer->Print(method->GetLeadingComments("//").c_str());
  printer->Print(
      *vars,
      "virtual ::shk::AnyPublisher<$ResponseStream$$Response$> $Method$(\n"
      "    const ::shk::CallContext &ctx, "
      "$RequestPrelude$$Request$$RequestPostlude$ &&"
      "request$RequestPlural$) = 0;\n");
  printer->Print(method->GetTrailingComments("//").c_str());
}

void PrintHeaderService(
    grpc_generator::Printer *printer,
    const grpc_generator::Service *service,
    std::map<std::string, std::string> *vars) {
  (*vars)["Service"] = service->name();

  printer->Print(service->GetLeadingComments("//").c_str());
  printer->Print(*vars,
                 "class $Service$ : public ::shk::Service {\n"
                 " public:\n");
  printer->Indent();

  printer->Print(*vars, "$Service$();\n");
  printer->Print(*vars, "virtual ~$Service$();\n");
  for (int i = 0; i < service->method_count(); ++i) {
    PrintHeaderMethod(printer, service->method(i).get(), vars);
  }

  printer->Print(
      *vars,
      "\nstatic ::std::unique_ptr<$Service$> NewClient(\n"
      "    const ::std::shared_ptr<::grpc::ChannelInterface> &channel,\n"
      "    const ::grpc::StubOptions &options = ::grpc::StubOptions());\n\n");

  printer->Print(
      *vars,
      "using UnderlyingService = $grpc_ns$$Service$;\n");
  printer->Print(
      *vars,
      "using ServiceInterface = $Service$;\n");
  printer->Print(
      *vars,
      "static void RegisterService(\n"
      "    ::shk::RsGrpcServer::Builder::ServiceBuilder<\n"
      "        UnderlyingService::AsyncService, $Service$> *builder);\n");

  printer->Outdent();
  printer->Print("};\n");
  printer->Print(service->GetTrailingComments("//").c_str());
}

std::string GetHeaderServices(
    grpc_generator::File *file,
    const Parameters &params) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars = GetSharedVars(*file, params);

    if (!params.rs_services_namespace.empty()) {
      vars["rs_services_namespace"] = params.rs_services_namespace;
      printer->Print(vars, "\nnamespace $rs_services_namespace$ {\n\n");
    }

    for (int i = 0; i < file->service_count(); ++i) {
      PrintHeaderService(printer.get(), file->service(i).get(), &vars);
      printer->Print("\n");
    }

    if (!params.rs_services_namespace.empty()) {
      printer->Print(vars, "}  // namespace $rs_services_namespace$\n\n");
    }
  }
  return output;
}

std::string GetHeaderEpilogue(
    grpc_generator::File *file,
    const Parameters & /*params*/) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;

    vars["filename"] = file->filename();
    vars["filename_identifier"] = FilenameIdentifier(file->filename());

    if (!file->package().empty()) {
      std::vector<std::string> parts = file->package_parts();

      for (auto part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer->Print(vars, "}  // namespace $part$\n");
      }
      printer->Print(vars, "\n");
    }

    printer->Print(vars, "\n");
    printer->Print(vars, "#endif  // GRPC_$filename_identifier$__INCLUDED\n");

    printer->Print(file->GetTrailingComments("//").c_str());
  }
  return output;
}

std::string GetSourcePrologue(
    grpc_generator::File *file,
    const Parameters & /*params*/) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;

    vars["filename"] = file->filename();
    vars["filename_base"] = file->filename_without_ext();
    vars["message_header_ext"] =
        grpc_cpp_generator::kCppGeneratorMessageHeaderExt;
    vars["rs_service_header_ext"] = kRsGeneratorServiceHeaderExt;

    printer->Print(
        vars, "// Generated by the rs-grpc plugin.\n");
    printer->Print(
        vars, "// If you make any local change, they will be lost.\n");
    printer->Print(vars, "// source: $filename$\n\n");

    printer->Print(
        vars, "#include \"$filename_base$$rs_service_header_ext$\"\n");
    printer->Print(vars, "\n");
  }
  return output;
}

std::string GetSourceIncludes(
    grpc_generator::File *file,
    const Parameters &params) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars;

    static const char *headers_strs[] = {
        "rs-grpc/client.h",
        "rs-grpc/server.h"};
    std::vector<std::string> headers(headers_strs, array_end(headers_strs));
    PrintIncludes(printer.get(), headers, params);

    if (!file->package().empty()) {
      std::vector<std::string> parts = file->package_parts();

      for (auto part = parts.begin(); part != parts.end(); part++) {
        vars["part"] = *part;
        printer->Print(vars, "namespace $part$ {\n");
      }
    }

    printer->Print(vars, "\n");
  }
  return output;
}

void PrintSourceClientMethod(
    grpc_generator::Printer *printer,
    const grpc_generator::Method *method,
    std::map<std::string, std::string> *vars) {
  (*vars)["Method"] = method->name();
  (*vars)["RequestPrelude"] =
      method->ClientStreaming() ? "::shk::AnyPublisher<" : "";
  (*vars)["Request"] = method->input_type_name();
  (*vars)["RequestPostlude"] =
      method->ClientStreaming() ? ">" : "";
  (*vars)["Response"] = method->output_type_name();
  (*vars)["ResponseStream"] = method->ServerStreaming() ? "/*stream*/ " : "";
  (*vars)["RequestPlural"] = method->ClientStreaming() ? "s" : "";

  printer->Print(
    *vars,
    "::shk::AnyPublisher<$ResponseStream$$Response$>\n"
    "$Method$(\n"
    "    const ::shk::CallContext &ctx,\n"
    "    $RequestPrelude$$Request$$RequestPostlude$ &&request$RequestPlural$) "
    "override {\n");
  printer->Print(
    *vars,
    "  return ::shk::AnyPublisher<$Response$>(\n"
    "      client_->Invoke(\n"
    "          ctx,\n"
    "          &$grpc_ns$$Service$::Stub::Async$Method$,\n"
    "          ::std::move(request$RequestPlural$)));\n"
    "}\n\n");
}

void PrintSourceService(
    grpc_generator::Printer *printer,
    const grpc_generator::Service *service,
    std::map<std::string, std::string> *vars) {
  (*vars)["Service"] = service->name();

  printer->Print(
      *vars,
      // Have spaces in the front to work around bug in protobufs printer.cc
      // that causes heap overflow (as caught by ASan) when at_start_of_line_.
      //
      // TODO(pgron): Investigate this further. I think the root cause might be
      // something else.
      " $ns$$Service$::$Service$() {}\n"
      " $ns$$Service$::~$Service$() {}\n\n");

  printer->Print("namespace {\n\n");
  printer->Print(
      *vars,
      "class Rs$Service$Client : "
      "public $ns$$Service$ {\n");
  printer->Print(" public:\n");
  printer->Indent();

  printer->Print(
      *vars,
      "Rs$Service$Client(\n"
      "    const ::std::shared_ptr<::grpc::ChannelInterface> &channel,\n"
      "    const ::grpc::StubOptions &options)\n"
      "    : client_(new ::shk::RsGrpcClient<$grpc_ns$$Service$::Stub>(\n"
      "          $grpc_ns$$Service$::NewStub(channel))) {}\n\n");

  for (int i = 0; i < service->method_count(); ++i) {
    PrintSourceClientMethod(printer, service->method(i).get(), vars);
  }

  printer->Outdent();
  printer->Print(" private:\n");
  printer->Indent();
  printer->Print(
      *vars,
      "::std::unique_ptr<::shk::RsGrpcClient<$grpc_ns$$Service$::Stub>> "
      "client_;\n");
  printer->Outdent();
  printer->Print("};\n\n");
  printer->Print("}  // anonymous namespace\n\n");

  printer->Print(
      *vars,
      "::std::unique_ptr<$ns$$Service$> $ns$$Service$::NewClient(\n"
      "    const ::std::shared_ptr<::grpc::ChannelInterface> &channel,\n"
      "    const ::grpc::StubOptions &options) {\n"
      "  ::std::unique_ptr<$ns$$Service$> client(new "
      "Rs$Service$Client(channel, options));\n"
      "  return client;\n"
      "}\n\n");

  printer->Print(
      *vars,
      "void $ns$$Service$::RegisterService(\n"
      "    ::shk::RsGrpcServer::Builder::ServiceBuilder<\n"
      "        UnderlyingService::AsyncService, $Service$> *builder) {\n");
  printer->Indent();
  if (service->method_count() > 0) {
    printer->Print("(*builder)");
    printer->Indent();
    printer->Indent();
    for (int i = 0; i < service->method_count(); ++i) {
      (*vars)["Method"] = service->method(i)->name();
      printer->Print("\n.RegisterMethod(");
      printer->Indent();
      printer->Indent();
      printer->Print(
          *vars, "\n&$grpc_ns$$Service$::AsyncService::Request$Method$,");
      printer->Print(
          *vars, "\n&$ns$$Service$::$Method$)");
      printer->Outdent();
      printer->Outdent();
    }
    printer->Outdent();
    printer->Outdent();
    printer->Print(";\n");
  }
  printer->Outdent();
  printer->Print("}\n\n");
}

std::string GetSourceServices(
    grpc_generator::File *file,
    const Parameters &params) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    auto printer = file->CreatePrinter(&output);
    std::map<std::string, std::string> vars = GetSharedVars(*file, params);

    for (int i = 0; i < file->service_count(); ++i) {
      PrintSourceService(printer.get(), file->service(i).get(), &vars);
      printer->Print("\n");
    }
  }
  return output;
}

std::string GetSourceEpilogue(
    grpc_generator::File *file,
    const Parameters & /*params*/) {
  std::string temp;

  if (!file->package().empty()) {
    std::vector<std::string> parts = file->package_parts();

    for (auto part = parts.begin(); part != parts.end(); part++) {
      temp.append("}  // namespace ");
      temp.append(*part);
      temp.append("\n");
    }
    temp.append("\n");
  }

  return temp;
}

}  // namespace rs_grpc_generator
